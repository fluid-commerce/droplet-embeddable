import { c as ce } from "./format-TjzP8gQX-Cs7Vwno2.js";
import { j as jd } from "./common-Badpcggq-Batnw2Ed.js";
const X = (e, o, d, g) => {
  let u = 0, l = 0, b = 0;
  const p = 0;
  return d ? g ? (l = o ? 60 : 0, u = o ? 60 : 0) : b = o ? 20 : 0 : g ? (l = e ? 60 : 0, u = e ? 60 : 0) : b = e ? 20 : 0, { left: u, right: l, top: b, bottom: p };
};
function K({
  displayAsPercentage: e = false,
  displayHorizontally: o = false,
  dps: d = void 0,
  isGroupedBar: g,
  lineMetrics: u,
  metric: l,
  metrics: b,
  results: p,
  reverseXAxis: L = false,
  secondAxisTitle: N = "",
  segment: G,
  showLabels: $ = false,
  showLegend: V = false,
  showSecondYAxis: I = false,
  showTotals: C = false,
  stackBars: h,
  stackMetrics: v = false,
  stacked: x = false,
  theme: f,
  xAxis: q,
  xAxisTitle: R = "",
  yAxisTitle: S = ""
}) {
  return {
    responsive: true,
    maintainAspectRatio: false,
    indexAxis: o ? "y" : "x",
    layout: {
      padding: X($, C, x, o)
    },
    scales: {
      y: {
        stacked: x || v,
        grace: "0%",
        grid: {
          display: false
        },
        max: e && !o ? g ? h ? 100 : void 0 : 100 : void 0,
        afterDataLimits: function(t) {
          const a = [
            ...l !== void 0 ? [l] : [],
            ...b || [],
            ...u && !I ? u : []
          ];
          jd(t, p, a, d);
        },
        ticks: {
          //https://www.chartjs.org/docs/latest/axes/labelling.html
          callback: function(t) {
            return o ? this.getLabelForValue(parseFloat(`${t}`)) : e ? `${t}%` : ce(typeof t == "number" ? t.toString() : t, {
              type: "number"
            });
          }
        },
        title: {
          display: !!S,
          text: S
        }
      },
      y1: {
        //optional second y-axis for optional line metrics
        display: I,
        grace: "0%",
        grid: {
          display: false
        },
        position: "right",
        title: {
          display: !!N,
          text: N
        },
        afterDataLimits: function(t) {
          const a = [...u && I ? u : []];
          jd(t, p, a, d);
        }
      },
      x: {
        reverse: L && !o,
        stacked: x || v,
        grid: {
          display: false
        },
        max: e && o ? g ? h ? 100 : void 0 : 100 : void 0,
        ticks: {
          //https://www.chartjs.org/docs/latest/axes/labelling.html
          callback: function(t) {
            return o ? e ? `${t}%` : ce(typeof t == "number" ? t.toString() : t, {
              type: "number"
            }) : this.getLabelForValue(parseFloat(`${t}`));
          }
        },
        title: {
          display: !!R,
          text: R
        }
      }
    },
    animation: {
      duration: 400,
      easing: "linear"
    },
    plugins: {
      legend: {
        display: V,
        position: "bottom",
        labels: {
          usePointStyle: true,
          boxHeight: 8
        }
      },
      tooltip: {
        //https://www.chartjs.org/docs/latest/configuration/tooltip.html
        callbacks: {
          label: function(t) {
            let a = t.dataset.label || "";
            const s = t.datasetIndex, i = [...b || [], ...u || []], r = b ? i[s] : l;
            if (t.parsed && typeof t.parsed == "object") {
              const n = o ? "x" : "y";
              a += `: ${ce(`${t.parsed[n]}`, {
                type: "number",
                dps: d,
                meta: e || r == null ? void 0 : r.meta
              })}`, e && (a += "%");
            }
            return a;
          }
        }
      },
      datalabels: {
        labels: {
          total: {
            anchor: (t) => {
              var n, c;
              const a = t.dataset, s = a.totals;
              if (!s)
                return "end";
              const i = (n = a.xAxisNames) == null ? void 0 : n[t.dataIndex], r = (c = s[i || ""]) == null ? void 0 : c.total;
              return r && r < 0 ? "start" : "end";
            },
            align: (t) => {
              var n, c;
              const a = t.dataset, s = a.totals;
              if (!s)
                return o ? "right" : "top";
              const i = (n = a.xAxisNames) == null ? void 0 : n[t.dataIndex], r = (c = s[i || ""]) == null ? void 0 : c.total;
              return r && r < 0 ? o ? "left" : "bottom" : o ? "right" : "top";
            },
            display: C && h ? "true" : false,
            backgroundColor: f.charts.bar.labels.total.backgroundColor,
            borderRadius: f.charts.bar.labels.total.borderRadius,
            color: f.charts.bar.labels.total.color,
            font: {
              size: f.charts.bar.labels.total.font.size,
              weight: f.charts.bar.labels.total.font.weight
            },
            formatter: (t, a) => {
              const s = a.dataset, i = s.xAxisNames, r = s.totals;
              if (!r || !i)
                return "";
              const n = i[a.dataIndex];
              if (a.datasetIndex === r[n].lastSegment && t !== null) {
                const k = e ? "100" : r[n].total.toString();
                let D = ce(k, {
                  type: "number",
                  dps: d,
                  meta: e || l == null ? void 0 : l.meta
                });
                return e && (D += "%"), D;
              } else
                return "";
            }
          },
          value: {
            //https://chartjs-plugin-datalabels.netlify.app/guide/
            anchor: x || v ? "center" : "end",
            align: x || v ? "center" : "end",
            display: $ ? "auto" : false,
            backgroundColor: f.charts.bar.labels.value.backgroundColor,
            borderRadius: f.charts.bar.labels.value.borderRadius,
            color: f.charts.bar.labels.value.color,
            font: {
              size: f.charts.bar.labels.value.font.size,
              weight: f.charts.bar.labels.value.font.weight
            },
            formatter: (t, a) => {
              const s = a.datasetIndex, i = [...b || [], ...u || []], r = b ? i[s] : l;
              if (t === null) return null;
              let n = ce(t, {
                type: "number",
                dps: d,
                meta: e || r == null ? void 0 : r.meta
              });
              return e && (n += "%"), n;
            }
          }
        }
      }
    }
  };
}
export {
  K
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0QmFyQ2hhcnRPcHRpb25zLUI0SUdQZlJULVE0ZktJNEtpLmpzIiwic291cmNlcyI6WyIvVXNlcnMvY2hyaXN0b3BoZXJjYXJsc29uL2ZsdWlkL2Ryb3BsZXQtZW1iZWRkYWJsZS9hcHAvZnJvbnRlbmQvZW1iZWRkYWJsZS9ub2RlX21vZHVsZXMvQGVtYmVkZGFibGUuY29tL3ZhbmlsbGEtY29tcG9uZW50cy9kaXN0L2dldEJhckNoYXJ0T3B0aW9ucy1CNElHUGZSVC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmIGFzIG0gfSBmcm9tIFwiLi9mb3JtYXQtVGp6UDhnUVguanNcIjtcbmltcG9ydCB7IGcgYXMgRiB9IGZyb20gXCIuL2NvbW1vbi1CYWRwY2dncS5qc1wiO1xuY29uc3QgWCA9IChlLCBvLCBkLCBnKSA9PiB7XG4gIGxldCB1ID0gMCwgbCA9IDAsIGIgPSAwO1xuICBjb25zdCBwID0gMDtcbiAgcmV0dXJuIGQgPyBnID8gKGwgPSBvID8gNjAgOiAwLCB1ID0gbyA/IDYwIDogMCkgOiBiID0gbyA/IDIwIDogMCA6IGcgPyAobCA9IGUgPyA2MCA6IDAsIHUgPSBlID8gNjAgOiAwKSA6IGIgPSBlID8gMjAgOiAwLCB7IGxlZnQ6IHUsIHJpZ2h0OiBsLCB0b3A6IGIsIGJvdHRvbTogcCB9O1xufTtcbmZ1bmN0aW9uIEsoe1xuICBkaXNwbGF5QXNQZXJjZW50YWdlOiBlID0gITEsXG4gIGRpc3BsYXlIb3Jpem9udGFsbHk6IG8gPSAhMSxcbiAgZHBzOiBkID0gdm9pZCAwLFxuICBpc0dyb3VwZWRCYXI6IGcsXG4gIGxpbmVNZXRyaWNzOiB1LFxuICBtZXRyaWM6IGwsXG4gIG1ldHJpY3M6IGIsXG4gIHJlc3VsdHM6IHAsXG4gIHJldmVyc2VYQXhpczogTCA9ICExLFxuICBzZWNvbmRBeGlzVGl0bGU6IE4gPSBcIlwiLFxuICBzZWdtZW50OiBHLFxuICBzaG93TGFiZWxzOiAkID0gITEsXG4gIHNob3dMZWdlbmQ6IFYgPSAhMSxcbiAgc2hvd1NlY29uZFlBeGlzOiBJID0gITEsXG4gIHNob3dUb3RhbHM6IEMgPSAhMSxcbiAgc3RhY2tCYXJzOiBoLFxuICBzdGFja01ldHJpY3M6IHYgPSAhMSxcbiAgc3RhY2tlZDogeCA9ICExLFxuICB0aGVtZTogZixcbiAgeEF4aXM6IHEsXG4gIHhBeGlzVGl0bGU6IFIgPSBcIlwiLFxuICB5QXhpc1RpdGxlOiBTID0gXCJcIlxufSkge1xuICByZXR1cm4ge1xuICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgIG1haW50YWluQXNwZWN0UmF0aW86ICExLFxuICAgIGluZGV4QXhpczogbyA/IFwieVwiIDogXCJ4XCIsXG4gICAgbGF5b3V0OiB7XG4gICAgICBwYWRkaW5nOiBYKCQsIEMsIHgsIG8pXG4gICAgfSxcbiAgICBzY2FsZXM6IHtcbiAgICAgIHk6IHtcbiAgICAgICAgc3RhY2tlZDogeCB8fCB2LFxuICAgICAgICBncmFjZTogXCIwJVwiLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgfSxcbiAgICAgICAgbWF4OiBlICYmICFvID8gZyA/IGggPyAxMDAgOiB2b2lkIDAgOiAxMDAgOiB2b2lkIDAsXG4gICAgICAgIGFmdGVyRGF0YUxpbWl0czogZnVuY3Rpb24odCkge1xuICAgICAgICAgIGNvbnN0IGEgPSBbXG4gICAgICAgICAgICAuLi5sICE9PSB2b2lkIDAgPyBbbF0gOiBbXSxcbiAgICAgICAgICAgIC4uLmIgfHwgW10sXG4gICAgICAgICAgICAuLi51ICYmICFJID8gdSA6IFtdXG4gICAgICAgICAgXTtcbiAgICAgICAgICBGKHQsIHAsIGEsIGQpO1xuICAgICAgICB9LFxuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIC8vaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmcvZG9jcy9sYXRlc3QvYXhlcy9sYWJlbGxpbmcuaHRtbFxuICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gbyA/IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZUZsb2F0KGAke3R9YCkpIDogZSA/IGAke3R9JWAgOiBtKHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB0LnRvU3RyaW5nKCkgOiB0LCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiAhIVMsXG4gICAgICAgICAgdGV4dDogU1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeTE6IHtcbiAgICAgICAgLy9vcHRpb25hbCBzZWNvbmQgeS1heGlzIGZvciBvcHRpb25hbCBsaW5lIG1ldHJpY3NcbiAgICAgICAgZGlzcGxheTogSSxcbiAgICAgICAgZ3JhY2U6IFwiMCVcIixcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgZGlzcGxheTogISFOLFxuICAgICAgICAgIHRleHQ6IE5cbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJEYXRhTGltaXRzOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgY29uc3QgYSA9IFsuLi51ICYmIEkgPyB1IDogW11dO1xuICAgICAgICAgIEYodCwgcCwgYSwgZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB4OiB7XG4gICAgICAgIHJldmVyc2U6IEwgJiYgIW8sXG4gICAgICAgIHN0YWNrZWQ6IHggfHwgdixcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGRpc3BsYXk6ICExXG4gICAgICAgIH0sXG4gICAgICAgIG1heDogZSAmJiBvID8gZyA/IGggPyAxMDAgOiB2b2lkIDAgOiAxMDAgOiB2b2lkIDAsXG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgLy9odHRwczovL3d3dy5jaGFydGpzLm9yZy9kb2NzL2xhdGVzdC9heGVzL2xhYmVsbGluZy5odG1sXG4gICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBvID8gZSA/IGAke3R9JWAgOiBtKHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyB0LnRvU3RyaW5nKCkgOiB0LCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgICAgICAgIH0pIDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKHBhcnNlRmxvYXQoYCR7dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIGRpc3BsYXk6ICEhUixcbiAgICAgICAgICB0ZXh0OiBSXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogXCJsaW5lYXJcIlxuICAgIH0sXG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IFYsXG4gICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICB1c2VQb2ludFN0eWxlOiAhMCxcbiAgICAgICAgICBib3hIZWlnaHQ6IDhcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgLy9odHRwczovL3d3dy5jaGFydGpzLm9yZy9kb2NzL2xhdGVzdC9jb25maWd1cmF0aW9uL3Rvb2x0aXAuaHRtbFxuICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICBsYWJlbDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgbGV0IGEgPSB0LmRhdGFzZXQubGFiZWwgfHwgXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LmRhdGFzZXRJbmRleCwgaSA9IFsuLi5iIHx8IFtdLCAuLi51IHx8IFtdXSwgciA9IGIgPyBpW3NdIDogbDtcbiAgICAgICAgICAgIGlmICh0LnBhcnNlZCAmJiB0eXBlb2YgdC5wYXJzZWQgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBjb25zdCBuID0gbyA/IFwieFwiIDogXCJ5XCI7XG4gICAgICAgICAgICAgIGEgKz0gYDogJHttKGAke3QucGFyc2VkW25dfWAsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGRwczogZCxcbiAgICAgICAgICAgICAgICBtZXRhOiBlIHx8IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIubWV0YVxuICAgICAgICAgICAgICB9KX1gLCBlICYmIChhICs9IFwiJVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhdGFsYWJlbHM6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgdG90YWw6IHtcbiAgICAgICAgICAgIGFuY2hvcjogKHQpID0+IHtcbiAgICAgICAgICAgICAgdmFyIG4sIGM7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSB0LmRhdGFzZXQsIHMgPSBhLnRvdGFscztcbiAgICAgICAgICAgICAgaWYgKCFzKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImVuZFwiO1xuICAgICAgICAgICAgICBjb25zdCBpID0gKG4gPSBhLnhBeGlzTmFtZXMpID09IG51bGwgPyB2b2lkIDAgOiBuW3QuZGF0YUluZGV4XSwgciA9IChjID0gc1tpIHx8IFwiXCJdKSA9PSBudWxsID8gdm9pZCAwIDogYy50b3RhbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHIgJiYgciA8IDAgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsaWduOiAodCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgbiwgYztcbiAgICAgICAgICAgICAgY29uc3QgYSA9IHQuZGF0YXNldCwgcyA9IGEudG90YWxzO1xuICAgICAgICAgICAgICBpZiAoIXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG8gPyBcInJpZ2h0XCIgOiBcInRvcFwiO1xuICAgICAgICAgICAgICBjb25zdCBpID0gKG4gPSBhLnhBeGlzTmFtZXMpID09IG51bGwgPyB2b2lkIDAgOiBuW3QuZGF0YUluZGV4XSwgciA9IChjID0gc1tpIHx8IFwiXCJdKSA9PSBudWxsID8gdm9pZCAwIDogYy50b3RhbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHIgJiYgciA8IDAgPyBvID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiIDogbyA/IFwicmlnaHRcIiA6IFwidG9wXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcGxheTogQyAmJiBoID8gXCJ0cnVlXCIgOiAhMSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZi5jaGFydHMuYmFyLmxhYmVscy50b3RhbC5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IGYuY2hhcnRzLmJhci5sYWJlbHMudG90YWwuYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgY29sb3I6IGYuY2hhcnRzLmJhci5sYWJlbHMudG90YWwuY29sb3IsXG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgIHNpemU6IGYuY2hhcnRzLmJhci5sYWJlbHMudG90YWwuZm9udC5zaXplLFxuICAgICAgICAgICAgICB3ZWlnaHQ6IGYuY2hhcnRzLmJhci5sYWJlbHMudG90YWwuZm9udC53ZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXR0ZXI6ICh0LCBhKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHMgPSBhLmRhdGFzZXQsIGkgPSBzLnhBeGlzTmFtZXMsIHIgPSBzLnRvdGFscztcbiAgICAgICAgICAgICAgaWYgKCFyIHx8ICFpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICBjb25zdCBuID0gaVthLmRhdGFJbmRleF07XG4gICAgICAgICAgICAgIGlmIChhLmRhdGFzZXRJbmRleCA9PT0gcltuXS5sYXN0U2VnbWVudCAmJiB0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IGUgPyBcIjEwMFwiIDogcltuXS50b3RhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxldCBEID0gbShrLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgZHBzOiBkLFxuICAgICAgICAgICAgICAgICAgbWV0YTogZSB8fCBsID09IG51bGwgPyB2b2lkIDAgOiBsLm1ldGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSAmJiAoRCArPSBcIiVcIiksIEQ7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIC8vaHR0cHM6Ly9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLm5ldGxpZnkuYXBwL2d1aWRlL1xuICAgICAgICAgICAgYW5jaG9yOiB4IHx8IHYgPyBcImNlbnRlclwiIDogXCJlbmRcIixcbiAgICAgICAgICAgIGFsaWduOiB4IHx8IHYgPyBcImNlbnRlclwiIDogXCJlbmRcIixcbiAgICAgICAgICAgIGRpc3BsYXk6ICQgPyBcImF1dG9cIiA6ICExLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBmLmNoYXJ0cy5iYXIubGFiZWxzLnZhbHVlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogZi5jaGFydHMuYmFyLmxhYmVscy52YWx1ZS5ib3JkZXJSYWRpdXMsXG4gICAgICAgICAgICBjb2xvcjogZi5jaGFydHMuYmFyLmxhYmVscy52YWx1ZS5jb2xvcixcbiAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgc2l6ZTogZi5jaGFydHMuYmFyLmxhYmVscy52YWx1ZS5mb250LnNpemUsXG4gICAgICAgICAgICAgIHdlaWdodDogZi5jaGFydHMuYmFyLmxhYmVscy52YWx1ZS5mb250LndlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdHRlcjogKHQsIGEpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcyA9IGEuZGF0YXNldEluZGV4LCBpID0gWy4uLmIgfHwgW10sIC4uLnUgfHwgW11dLCByID0gYiA/IGlbc10gOiBsO1xuICAgICAgICAgICAgICBpZiAodCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIGxldCBuID0gbSh0LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBkcHM6IGQsXG4gICAgICAgICAgICAgICAgbWV0YTogZSB8fCByID09IG51bGwgPyB2b2lkIDAgOiByLm1ldGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBlICYmIChuICs9IFwiJVwiKSwgbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQge1xuICBLIGFzIGdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRCYXJDaGFydE9wdGlvbnMtQjRJR1BmUlQuanMubWFwXG4iXSwibmFtZXMiOlsiRiIsIm0iXSwibWFwcGluZ3MiOiI7O0FBRUEsTUFBTSxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTTtBQUN4QixNQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUN0QixRQUFNLElBQUk7QUFDVixTQUFPLElBQUksS0FBSyxJQUFJLElBQUksS0FBSyxHQUFHLElBQUksSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxLQUFLLEdBQUcsSUFBSSxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FB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QUFNO0FBQ25CLG9CQUFNLElBQUksRUFBRSxTQUFTLElBQUksRUFBRSxZQUFZLElBQUksRUFBRTtBQUM3QyxrQkFBSSxDQUFDLEtBQUssQ0FBQztBQUNULHVCQUFPO0FBQ1Qsb0JBQU0sSUFBSSxFQUFFLEVBQUUsU0FBUztBQUN2QixrQkFBSSxFQUFFLGlCQUFpQixFQUFFLENBQUMsRUFBRSxlQUFlLE1BQU0sTUFBTTtBQUNyRCxzQkFBTSxJQUFJLElBQUksUUFBUSxFQUFFLENBQUMsRUFBRSxNQUFNLFNBQVE7QUFDekMsb0JBQUksSUFBSUEsR0FBRSxHQUFHO0FBQUEsa0JBQ1gsTUFBTTtBQUFBLGtCQUNOLEtBQUs7QUFBQSxrQkFDTCxNQUFNLEtBQUssS0FBSyxPQUFPLFNBQVMsRUFBRTtBQUFBLGdCQUNwRCxDQUFpQjtBQUNELHVCQUFPLE1BQU0sS0FBSyxNQUFNO0FBQUEsY0FDMUI7QUFDRSx1QkFBTztBQUFBLFlBQ1g7QUFBQSxVQUNaO0FBQUEsVUFDVSxPQUFPO0FBQUE7QUFBQSxZQUVMLFFBQVEsS0FBSyxJQUFJLFdBQVc7QUFBQSxZQUM1QixPQUFPLEtBQUssSUFBSSxXQUFXO0FBQUEsWUFDM0IsU0FBUyxJQUFJLFNBQVM7QUFBQSxZQUN0QixpQkFBaUIsRUFBRSxPQUFPLElBQUksT0FBTyxNQUFNO0FBQUEsWUFDM0MsY0FBYyxFQUFFLE9BQU8sSUFBSSxPQUFPLE1BQU07QUFBQSxZQUN4QyxPQUFPLEVBQUUsT0FBTyxJQUFJLE9BQU8sTUFBTTtBQUFBLFlBQ2pDLE1BQU07QUFBQSxjQUNKLE1BQU0sRUFBRSxPQUFPLElBQUksT0FBTyxNQUFNLEtBQUs7QUFBQSxjQUNyQyxRQUFRLEVBQUUsT0FBTyxJQUFJLE9BQU8sTUFBTSxLQUFLO0FBQUEsWUFDckQ7QUFBQSxZQUNZLFdBQVcsQ0FBQyxHQUFHLE1BQU07QUFDbkIsb0JBQU0sSUFBSSxFQUFFLGNBQWMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFBLEdBQUksR0FBRyxLQUFLLENBQUEsQ0FBRSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsSUFBSTtBQUN2RSxrQkFBSSxNQUFNLEtBQU0sUUFBTztBQUN2QixrQkFBSSxJQUFJQSxHQUFFLEdBQUc7QUFBQSxnQkFDWCxNQUFNO0FBQUEsZ0JBQ04sS0FBSztBQUFBLGdCQUNMLE1BQU0sS0FBSyxLQUFLLE9BQU8sU0FBUyxFQUFFO0FBQUEsY0FDbEQsQ0FBZTtBQUNELHFCQUFPLE1BQU0sS0FBSyxNQUFNO0FBQUEsWUFDMUI7QUFBQSxVQUNaO0FBQUEsUUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNBO0FBQUEsRUFDQTtBQUNBOyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswXX0=
